# 단위 테스트란 무엇인가

## 단위 테스트란?

### [P.52]단위테스트

- 작은 코드조각(Unit)을 검증
- 빠르게 테스트 수행
- 격리된 방식으로 자동화된 테스트

## 공유 의존성, 비공개 의존성, 휘발성 의존성 간의 차이점

### 공유 의존성

테스트간 공유되며 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성

- Static mutable field
- Database

### 비공개 의존성

공유하지 않는 의존성

### 프로세스 외부 의존성

앱 실행 프로세스 외부에서 실행되는 의존성이며, 아직 메모리에 없는 데이터에 대한 프록시

- Local Database > 외부 의존성이자 공유 의존성
- test-container를 사용해서 테스트 케이스마다 다른 DB 컨테이너 > 외부 의존성이자 공유하지 않는 의존성

## 단위 테스트의 두 분파: 고전파와 런던파

### [P.53]격리 문제에 대한 런던파의 접근

하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면, 이 모든 의존성을 테스트 대역으로 대체한다.

**이점**

- 테스트가 실패하면, 코드베이스의 어느 부분이 고장 났는지 확실하게 알 수 있음
- 객체 그래프를 분할 할 수 있다
  - 테스트 대역을 사용하여, 직접적인 의존성을 대체할 수 있고, 의존성의 의존성을 다룰 필요도 없다.
- 프로젝트 전체에 걸쳐 간단한 테스트 Suite 구조를 가져갈 수 있다.

**\[P.55\] 예제 2.1 고전적인 스타일로 작성된 테스트**

> 별개의 개념  
> SUT(System Under Test) - 테스트의 대상이되는 시스템 코드  
> 협력자 - 테스트에 필요한 객체

[p.56 고전스타일 예제코드](https://github.com/AcornPublishing/unit-testing/blob/main/Book/Chapter2/Listing1/CustomerTests.cs)

Customer이 샘플코드에서 SUT인 Store(협력자)가 필요한 이유

- 테스트 대상 메서드(MUT, Method Under Test)를 컴파일 하기 위해서
- 테스트 대상 메서드의 결과를 검증하기 위해서

협력자(Store)를 테스트 대역으로 대체하지 않고, **운영용 인스턴스**를 사용한다.  
따라서, SUT인 Customer뿐만아니라 협력자인 Store 또한 같이 검증된다.

Store 내부에 버그가 있을시 단위테스트는 실패하므로 테스트에서 두클래스는 서로 격리되어 있지 않다.

**\[P.58\] 예제 2.2 런던 스타일로 작성된 단위 테스트**

[p.58 런던스타일 예제코드](https://github.com/AcornPublishing/unit-testing/blob/main/Book/Chapter2/Listing2/CustomerTests.cs])

Store의 실제 인스턴스를 생성하지 않고, Mock<T>를 사용해 대체한다.

- 구체 클래스를 목으로 만드는 행위는 안티 패턴이다. (11장)

상점 상태 검증 (고전) -> Customer <> Store간 상호 작용만 검사 (여기선 호출여부)

### \[P.60\] 격리문제에 대한 고전파의 접근

단위테스트의 3번째 속성

- 격리된 방식으로 테스트를 진행한다.

격리된 방식을 바라보는 관점

- 코드를 격리하여 테스트 X
- 단위 테스트를 격리해서 실행한다.

테스트하고자 하는 클래스들이 모두 메모리에 상주하고 공유 상태에만 도달하지 않으면 된다.
-> 테스트간 서로 소통, 실행 컨텍스트에 영향을 주는 것을 피해야 한다.

### 고전파와 런던파의 비교

**런던파 장점**

- 입자성이 좋다 / 한번에 한 클래스만 확인
- 클래스 그래프가 커져도 테스트 하기 쉽다.
- 테스트 실패시 어떤 기능이 실패했는지 확실히 알 수 있다.

**저자의 반박**

- 입자성이 좋다

  > 우리집 강아지를 부르면 먼저 왼쪽 앞다리를 움직이고, 이어서 오른쪽 앞다리를 움직이고 ...

  - 과도한 명세 문제 / 너무 작은 단위이며, 의미를 지니지 않는다.

- 클래스 그래프가 커져도 테스트 하기 쉽다.

  > 좋은 부정 지표 / 비교적 높은 정확도로 저품질 예측

  - 상호 연결된 클래스가 복잡하고 커진다면, 이것은 설계의 문제다.

- 테스트 실패시 어떤 기능이 실패했는지 확실히 알 수 있다.
  > 테스트를 정기적으로 한다면, 그리 어렵지 않게 문제를 찾을 수 있다.
  - 마지막 수정을 알고 있으니
  - 또한, 계단식 실패로 인해, 방금 고장낸 코드의 영향도 파악을 할 수 있다

**정리**

- 런던파 = 테스트 대상 단위(보통 단일 클래스)의 분리 , 불변의존성을 제외한 모든 의존성 = 테스트 대역
- 고전파 = 단위가 아닌 단위 테스트의 분리 / (동작 단위), 공유 의존성만 테스트 대역으로 대체

## 단위 테스트, 통합 테스트, 엔드 투 엔드 테스트의 차이점

### 런던파와 고전파의 통합테스트에 대한 관점 차이

**런던파**

- 실제 협력자 객체를 사용하는 모든 테스트 = 통합 테스트
  - 고전파가 작성한 대부분의 테스트 = 통합테스트

위에서 언급한, 단위테스트 3가지 특징 중 하나라도 만족시키지 못한다면, 이는 곧 통합테스트로 볼 수 있다.

---

아직 이해하지 못한 것  
비공개 의존성, 공개의존성 공유의존성 개념
